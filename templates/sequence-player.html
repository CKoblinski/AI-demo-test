<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{{SCENE_TITLE}}</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'Courier New', monospace;
    overflow: hidden;
  }

  /* ── 9:16 Vertical Frame ── */
  #scene {
    position: relative;
    width: 1080px;
    height: 1920px;
    overflow: hidden;
    background: #000;
    image-rendering: pixelated;
  }

  /* ── Sequence Sections ── */
  .sequence {
    position: absolute;
    inset: 0;
    opacity: 0;
    pointer-events: none;
    overflow: hidden;
  }

  .sequence.active {
    opacity: 1;
    pointer-events: auto;
  }

  /* Fade transition helpers: .crossfade adds the CSS transition,
     then toggle .visible to drive the animation */
  .sequence.crossfade {
    transition: opacity 400ms ease-in-out;
  }

  .sequence.visible {
    opacity: 1;
    pointer-events: auto;
  }

  /* ── Flash Overlay ── */
  #flash-overlay {
    position: absolute;
    inset: 0;
    background: #fff;
    opacity: 0;
    pointer-events: none;
    z-index: 100;
  }

  /* ── Background Layer ── */
  .seq-bg {
    position: absolute;
    inset: 0;
    background-size: cover;
    background-position: center;
    image-rendering: pixelated;
    animation: bg-breathe 5s ease-in-out infinite;
  }

  @keyframes bg-breathe {
    0%, 100% { filter: brightness(0.49); }
    50%      { filter: brightness(0.52); }
  }

  /* ── Vignette ── */
  .seq-bg::after {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.6) 100%);
  }

  /* ── Torch Glow Overlays ── */
  .torch-glow {
    position: absolute;
    width: 240px;
    height: 240px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255,160,50,0.18) 0%, transparent 70%);
    mix-blend-mode: screen;
    pointer-events: none;
    animation: glow-pulse 5s ease-in-out infinite;
    z-index: 1;
  }

  .torch-glow:nth-child(2) {
    animation-delay: -2s;
    width: 200px;
    height: 200px;
  }

  @keyframes glow-pulse {
    0%, 100% { opacity: 0.15; }
    50%      { opacity: 0.25; }
  }

  /* ── Dialogue Box Area ── */
  .dialogue-box {
    position: absolute;
    bottom: 240px;
    left: 40px;
    right: 40px;
    display: flex;
    gap: 24px;
    align-items: flex-end;
    z-index: 10;
  }

  /* ── Character Portrait — Multi-Frame ── */
  .portrait-frame {
    flex-shrink: 0;
    width: 280px;
    height: 280px;
    border-radius: 12px;
    overflow: hidden;
    position: relative;
    animation: portrait-bob 3s ease-in-out infinite;
    image-rendering: pixelated;
  }

  .portrait-variant {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    image-rendering: pixelated;
    opacity: 0;
  }

  .portrait-variant.active {
    opacity: 1;
  }

  /* ── Text Box ── */
  .text-frame {
    flex: 1;
    background: rgba(10, 8, 20, 0.92);
    border-radius: 12px;
    padding: 28px 32px;
    min-height: 280px;
    position: relative;
    box-shadow:
      0 0 30px rgba(0,0,0,0.8),
      inset 0 0 60px rgba(0,0,0,0.3);
  }

  /* ── Decorative corners ── */
  .text-frame::before,
  .text-frame::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    border-color: var(--char-color, #e8a033);
    border-style: solid;
  }
  .text-frame::before {
    top: 8px; left: 8px;
    border-width: 3px 0 0 3px;
  }
  .text-frame::after {
    bottom: 8px; right: 8px;
    border-width: 0 3px 3px 0;
  }

  /* ── Character Name ── */
  .char-name {
    font-size: 36px;
    font-weight: bold;
    margin-bottom: 16px;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  /* ── Dialogue Text ── */
  .dialogue-text {
    font-size: 36px;
    line-height: 1.5;
    color: #e8e4d8;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    min-height: 100px;
    transition: opacity 0.3s;
  }

  /* Characters revealed by JS typewriter */
  .char {
    opacity: 0;
    display: inline;
  }
  .char.visible {
    opacity: 1;
  }

  /* ── Cursor ── */
  .cursor {
    display: inline-block;
    width: 3px;
    height: 32px;
    vertical-align: text-bottom;
    animation: cursor-blink 0.8s step-end infinite;
    margin-left: 2px;
  }

  @keyframes portrait-bob {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
  }

  @keyframes cursor-blink {
    0%, 49% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }

  /* ── Action Closeup — Full-Frame Image ── */
  .action-frame-img {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    image-rendering: pixelated;
    opacity: 0;
  }

  .action-frame-img.active {
    opacity: 1;
  }

  /* ── Establishing Shot — Static BG with cinematic bars ── */
  .establishing-bars {
    position: absolute;
    left: 0;
    right: 0;
    height: 120px;
    background: #000;
    z-index: 5;
  }

  .establishing-bars.top { top: 0; }
  .establishing-bars.bottom { bottom: 0; }

  /* ── Reaction Shot — Portrait centred, larger ── */
  .reaction-portrait {
    position: absolute;
    width: 500px;
    height: 500px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -60%);
    border-radius: 16px;
    overflow: hidden;
    image-rendering: pixelated;
    animation: portrait-bob 3s ease-in-out infinite;
  }

  .reaction-portrait img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    image-rendering: pixelated;
  }

  .reaction-label {
    position: absolute;
    bottom: 320px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 48px;
    font-weight: bold;
    letter-spacing: 3px;
    text-transform: uppercase;
    z-index: 10;
  }

  /* ── Ambient Particles ── */
  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    pointer-events: none;
  }

  /* ── Responsive scaling ── */
  @media (max-height: 1920px) {
    #scene {
      transform-origin: top center;
      transform: scale(calc(100vh / 1920));
    }
  }
</style>
</head>
<body>

<div id="scene">
  <!-- Sequences injected by JS -->
  <div id="flash-overlay"></div>

  <!-- Ambient particles (shared across all sequences) -->
  <div id="particles"></div>
</div>

<script>
  // ══════════════════════════════════════════
  // Configuration (injected by assembler)
  // ══════════════════════════════════════════
  const SEQUENCES = {{SEQUENCES_JSON}};
  const TOTAL_DURATION_MS = {{TOTAL_DURATION_MS}};

  // ══════════════════════════════════════════
  // State
  // ══════════════════════════════════════════
  let currentIndex = -1;
  let sequenceTimers = [];  // all active timers for current sequence
  let mouthTimers = [];     // mouth animation intervals
  let frameTimers = [];     // action frame cycling intervals

  const scene = document.getElementById('scene');
  const flashOverlay = document.getElementById('flash-overlay');
  const particlesEl = document.getElementById('particles');

  // ══════════════════════════════════════════
  // DOM Building
  // ══════════════════════════════════════════

  const sectionElements = [];

  SEQUENCES.forEach((seq, i) => {
    const section = document.createElement('section');
    section.className = 'sequence';
    section.dataset.index = i;
    section.dataset.type = seq.type;

    // Build inner content based on type
    switch (seq.type) {
      case 'dialogue':
        section.innerHTML = buildDialogueHTML(seq, i);
        break;
      case 'action_closeup':
        section.innerHTML = buildActionHTML(seq, i);
        break;
      case 'establishing_shot':
        section.innerHTML = buildEstablishingHTML(seq, i);
        break;
      case 'reaction':
        section.innerHTML = buildReactionHTML(seq, i);
        break;
      default:
        section.innerHTML = buildEstablishingHTML(seq, i);
    }

    // Insert before flash overlay so flash stays on top
    scene.insertBefore(section, flashOverlay);
    sectionElements.push(section);
  });

  // ── Dialogue HTML Builder ──
  function buildDialogueHTML(seq, idx) {
    const color = seq.charColor || '#e8a033';
    const portraits = (seq.portraitImgs || []).map((src, i) =>
      `<img class="portrait-variant${i === 0 ? ' active' : ''}" src="${src}" data-frame="${i}" data-seq="${idx}" alt="frame ${i}">`
    ).join('\n');

    return `
      <div class="seq-bg" style="background-image: url('${seq.backgroundSrc || ''}')"></div>
      <div class="torch-glow" style="top: 25%; left: 25%"></div>
      <div class="torch-glow" style="top: 35%; left: 70%"></div>
      <div class="dialogue-box">
        <div class="portrait-frame" style="
          border: 6px solid ${color};
          box-shadow: 0 0 20px ${color}44, inset 0 0 20px rgba(0,0,0,0.5);
          --char-color: ${color};
        ">
          ${portraits}
        </div>
        <div class="text-frame" style="
          border: 4px solid ${color}88;
          --char-color: ${color};
        " data-color="${color}">
          <div class="char-name" style="color: ${color}; text-shadow: 0 0 12px ${color}66;">${escapeHTML(seq.charName || 'Character')}</div>
          <div class="dialogue-text" data-seq="${idx}"></div>
          <span class="cursor" style="background: ${color};"></span>
        </div>
      </div>
    `;
  }

  // ── Action Closeup HTML Builder ──
  function buildActionHTML(seq, idx) {
    const frames = (seq.frameImgs || []).map((src, i) =>
      `<img class="action-frame-img${i === 0 ? ' active' : ''}" src="${src}" data-frame="${i}" data-seq="${idx}" alt="action frame ${i}">`
    ).join('\n');

    // Use first frame as a dim background if available
    const bgSrc = seq.backgroundSrc || (seq.frameImgs && seq.frameImgs[0]) || '';

    return `
      <div class="seq-bg" style="background-image: url('${bgSrc}'); filter: brightness(0.25);"></div>
      ${frames}
    `;
  }

  // ── Establishing Shot HTML Builder ──
  function buildEstablishingHTML(seq, idx) {
    return `
      <div class="seq-bg" style="background-image: url('${seq.backgroundSrc || ''}'); animation: bg-breathe 5s ease-in-out infinite, estab-zoom 6s ease-out forwards;"></div>
      <div class="torch-glow" style="top: 30%; left: 20%"></div>
      <div class="torch-glow" style="top: 40%; left: 75%"></div>
      <div class="establishing-bars top"></div>
      <div class="establishing-bars bottom"></div>
    `;
  }

  // ── Reaction HTML Builder ──
  function buildReactionHTML(seq, idx) {
    const color = seq.charColor || '#e8a033';
    const portraitSrc = (seq.portraitImgs && seq.portraitImgs[0]) || '';

    return `
      <div class="seq-bg" style="background-image: url('${seq.backgroundSrc || ''}');"></div>
      <div class="torch-glow" style="top: 25%; left: 25%"></div>
      <div class="torch-glow" style="top: 35%; left: 70%"></div>
      <div class="reaction-portrait" style="
        border: 8px solid ${color};
        box-shadow: 0 0 40px ${color}66;
      ">
        <img src="${portraitSrc}" alt="${escapeHTML(seq.charName || 'Character')}">
      </div>
      <div class="reaction-label" style="
        color: ${color};
        text-shadow: 0 0 20px ${color}88, 2px 2px 4px rgba(0,0,0,0.9);
      ">${escapeHTML(seq.charName || '')}</div>
    `;
  }

  // ══════════════════════════════════════════
  // Transition Engine
  // ══════════════════════════════════════════

  function transitionTo(nextIndex) {
    const prevIndex = currentIndex;
    const seq = SEQUENCES[nextIndex];
    const transitionType = seq.transitionIn || 'cut';

    // Stop animations from previous sequence
    stopSequenceAnimations();

    switch (transitionType) {
      case 'fade':
        doFadeTransition(prevIndex, nextIndex);
        break;
      case 'flash':
        doFlashTransition(prevIndex, nextIndex);
        break;
      case 'cut':
      default:
        doCutTransition(prevIndex, nextIndex);
        break;
    }
  }

  function doCutTransition(prevIndex, nextIndex) {
    // Instant swap
    if (prevIndex >= 0) {
      sectionElements[prevIndex].className = 'sequence';
    }
    sectionElements[nextIndex].className = 'sequence active';
    currentIndex = nextIndex;
    startSequenceAnimations(nextIndex);
  }

  function doFadeTransition(prevIndex, nextIndex) {
    const nextEl = sectionElements[nextIndex];

    // Place next element in DOM flow at opacity 0 (base .sequence = opacity:0)
    nextEl.className = 'sequence';
    // Force reflow to paint the opacity:0 state
    void nextEl.offsetWidth;

    // Add transition class, then set visible — CSS transition animates 0 -> 1
    nextEl.className = 'sequence crossfade visible';

    if (prevIndex >= 0) {
      const prevEl = sectionElements[prevIndex];
      // Previous was .active (opacity:1). Switch to crossfade without .visible
      // so it transitions from 1 -> 0
      prevEl.className = 'sequence crossfade';
    }

    const t = setTimeout(() => {
      if (prevIndex >= 0) {
        sectionElements[prevIndex].className = 'sequence';
      }
      nextEl.className = 'sequence active';
    }, 400);
    sequenceTimers.push(t);

    currentIndex = nextIndex;
    startSequenceAnimations(nextIndex);
  }

  function doFlashTransition(prevIndex, nextIndex) {
    // Flash white, then reveal new section
    flashOverlay.style.transition = 'none';
    flashOverlay.style.opacity = '1';

    const t1 = setTimeout(() => {
      // Swap sections under the flash
      if (prevIndex >= 0) {
        sectionElements[prevIndex].className = 'sequence';
      }
      sectionElements[nextIndex].className = 'sequence active';
      currentIndex = nextIndex;

      // Fade out flash
      flashOverlay.style.transition = 'opacity 200ms ease-out';
      flashOverlay.style.opacity = '0';

      startSequenceAnimations(nextIndex);
    }, 200);
    sequenceTimers.push(t1);
  }

  // ══════════════════════════════════════════
  // Sequence Animation Controllers
  // ══════════════════════════════════════════

  function startSequenceAnimations(index) {
    const seq = SEQUENCES[index];
    const section = sectionElements[index];

    switch (seq.type) {
      case 'dialogue':
        startDialogueAnimation(seq, section, index);
        break;
      case 'action_closeup':
        startActionAnimation(seq, section, index);
        break;
      case 'establishing_shot':
        // Static with torch flicker — no extra JS needed
        break;
      case 'reaction':
        // Static portrait — no extra JS needed
        break;
    }
  }

  function stopSequenceAnimations() {
    // Clear all dialogue / frame timers
    mouthTimers.forEach(t => clearInterval(t));
    frameTimers.forEach(t => clearInterval(t));
    sequenceTimers.forEach(t => clearTimeout(t));
    mouthTimers = [];
    frameTimers = [];
    sequenceTimers = [];
  }

  // ── Dialogue Animation ──

  function startDialogueAnimation(seq, section, seqIndex) {
    const textEl = section.querySelector('.dialogue-text');
    const portraits = section.querySelectorAll('.portrait-variant');
    const cursorEl = section.querySelector('.cursor');
    const lines = seq.dialogueLines || [];
    const mouthCycleMs = seq.mouthCycleMs || 150;
    const linePauseMs = seq.linePauseMs || 1500;
    const portraitCount = portraits.length;

    let currentLine = 0;
    let charIndex = 0;
    let charSpans = [];
    let mouthFrame = 0;
    let mouthDirection = 1;
    let isTalking = false;

    // Mouth cycling
    function cycleMouth() {
      if (!isTalking || portraitCount <= 1) return;
      mouthFrame += mouthDirection;
      if (mouthFrame >= portraitCount - 1) mouthDirection = -1;
      if (mouthFrame <= 0) mouthDirection = 1;
      portraits.forEach((p, i) => p.classList.toggle('active', i === mouthFrame));
    }

    function startTalking() {
      if (portraitCount <= 1) return;
      isTalking = true;
      mouthFrame = 0;
      mouthDirection = 1;
      const mt = setInterval(cycleMouth, mouthCycleMs);
      mouthTimers.push(mt);
    }

    function stopTalking() {
      isTalking = false;
      mouthTimers.forEach(t => clearInterval(t));
      mouthTimers = [];
      portraits.forEach((p, i) => p.classList.toggle('active', i === 0));
    }

    function setupLine(lineIndex) {
      const line = lines[lineIndex];
      if (!line) return;
      textEl.innerHTML = '';
      textEl.style.opacity = '1';
      charSpans = [];
      charIndex = 0;

      for (let i = 0; i < line.text.length; i++) {
        if (line.text[i] === '\n') {
          textEl.appendChild(document.createElement('br'));
        } else {
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = line.text[i];
          textEl.appendChild(span);
          charSpans.push(span);
        }
      }
    }

    function typeNextChar() {
      if (charIndex >= charSpans.length) {
        // Line done
        clearTypeTimer();
        stopTalking();
        if (currentLine < lines.length - 1) {
          const t = setTimeout(clearAndNextLine, linePauseMs);
          sequenceTimers.push(t);
        }
        return;
      }
      charSpans[charIndex].classList.add('visible');
      charIndex++;
    }

    let typeTimer = null;
    function clearTypeTimer() {
      if (typeTimer) { clearInterval(typeTimer); typeTimer = null; }
    }

    function clearAndNextLine() {
      textEl.style.opacity = '0';
      const t = setTimeout(() => {
        currentLine++;
        setupLine(currentLine);
        startTypingLine();
      }, 400);
      sequenceTimers.push(t);
    }

    function startTypingLine() {
      const line = lines[currentLine];
      if (!line) return;
      startTalking();
      typeTimer = setInterval(typeNextChar, line.speed || 55);
      sequenceTimers.push(typeTimer);
    }

    // Kick off after brief pause
    if (lines.length > 0) {
      setupLine(0);
      const t = setTimeout(startTypingLine, 800);
      sequenceTimers.push(t);
    }
  }

  // ── Action Frame Animation ──

  function startActionAnimation(seq, section, seqIndex) {
    const frameImgs = section.querySelectorAll('.action-frame-img');
    const frameCount = frameImgs.length;
    if (frameCount <= 1) return;

    const frameDurationMs = seq.frameDurationMs || 300;
    const bounceMode = seq.bounceMode !== false; // default true

    let currentFrame = 0;
    let direction = 1;

    function cycleFrame() {
      // Deactivate current
      frameImgs.forEach(f => f.classList.remove('active'));

      if (bounceMode) {
        currentFrame += direction;
        if (currentFrame >= frameCount - 1) direction = -1;
        if (currentFrame <= 0) direction = 1;
      } else {
        currentFrame = (currentFrame + 1) % frameCount;
      }

      frameImgs[currentFrame].classList.add('active');
    }

    const ft = setInterval(cycleFrame, frameDurationMs);
    frameTimers.push(ft);
  }

  // ══════════════════════════════════════════
  // Timeline Controller
  // ══════════════════════════════════════════

  let timelineTimer = null;

  function runTimeline() {
    function playSequence(index) {
      if (index >= SEQUENCES.length) return; // done — last frame stays

      transitionTo(index);

      const duration = SEQUENCES[index].durationMs || 5000;
      timelineTimer = setTimeout(() => {
        playSequence(index + 1);
      }, duration);
    }

    playSequence(0);
  }

  // ══════════════════════════════════════════
  // Ambient Particles
  // ══════════════════════════════════════════

  function createParticle(color) {
    const p = document.createElement('div');
    p.className = 'particle';
    const x = Math.random() * 1080;
    const duration = 8 + Math.random() * 12;
    const delay = Math.random() * 10;
    const size = 2 + Math.random() * 4;
    const drift = ((Math.random() - 0.5) * 200).toFixed(0);

    p.style.cssText = `
      left: ${x}px;
      bottom: -20px;
      width: ${size}px;
      height: ${size}px;
      background: ${color}33;
      opacity: ${(0.1 + Math.random() * 0.3).toFixed(2)};
      animation: float-up-${drift} ${duration}s ${delay}s linear infinite;
    `;

    if (!document.querySelector(`style[data-drift="${drift}"]`)) {
      const style = document.createElement('style');
      style.dataset.drift = drift;
      style.textContent = `
        @keyframes float-up-${drift} {
          0%   { transform: translateY(0) translateX(0); opacity: 0; }
          10%  { opacity: 0.3; }
          90%  { opacity: 0.1; }
          100% { transform: translateY(-2100px) translateX(${drift}px); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }

    particlesEl.appendChild(p);
  }

  // Establishing shot slow zoom keyframe
  (function() {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes estab-zoom {
        0%   { transform: scale(1.0); }
        100% { transform: scale(1.06); }
      }
    `;
    document.head.appendChild(style);
  })();

  // Pick particle color from first dialogue sequence, or default warm gold
  const particleColor = (function() {
    for (const seq of SEQUENCES) {
      if (seq.charColor) return seq.charColor;
    }
    return '#e8a033';
  })();

  for (let i = 0; i < 15; i++) createParticle(particleColor);

  // ══════════════════════════════════════════
  // Utility
  // ══════════════════════════════════════════

  function escapeHTML(str) {
    const d = document.createElement('div');
    d.textContent = str || '';
    return d.innerHTML;
  }

  // ══════════════════════════════════════════
  // Start!
  // ══════════════════════════════════════════

  runTimeline();
</script>

</body>
</html>
